import org.gradle.internal.os.OperatingSystem;

/*
 * This build file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java Library project to get you started.
 * For more details take a look at the Java Libraries chapter in the Gradle
 * user guide available at https://docs.gradle.org/4.4.1/userguide/java_library_plugin.html
 */

// Apply the java-library plugin to add support for Java Library
apply plugin: 'java-library'

// In this section you declare where to find the dependencies of your project
repositories {
    // Use jcenter for resolving your dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

//Dependencies section
dependencies {
    // Use JUnit test framework
    testImplementation 'junit:junit:4.12'
}

def cppSources = rootProject.file("src/main/cpp/org.nanosite.warp")

def getJniPath() {
    if (OperatingSystem.current().isMacOsX()) {
        return new File(rootDir, "jnilibs/mac")
    } else if (OperatingSystem.current().isLinux()) {
        return new File(rootDir, "jnilibs/linux")
    } else if (OperatingSystem.current().isWindows()) {
        return new File(rootDir, "jnilibs/windows-64")
    } else {
        throw new GradleException("unsupported operating system")
    }
}
def availableProcessors = Runtime.runtime.availableProcessors()


List<String> jniClasses = ["org.nanosite.warp.jni.Warp", "org.nanosite.warp.jni.WarpFunctionBlock",
                  "org.nanosite.warp.jni.WarpBehavior", "org.nanosite.warp.jni.WarpStep"]


task generateJniHeaders(type:Exec) {
    def classpath = sourceSets.main.output.classesDirs.asPath
    def nativeIncludes = new File(cppSources, "src-gen")

    List<String> args = ["javah", "-d", nativeIncludes , "-classpath", classpath]

    doFirst {
        mkdir(nativeIncludes)
    }

    commandLine  args + jniClasses
    dependsOn classes
}

task runCMake(type:Exec) {
    doFirst{
        mkdir(buildDir)
    }
    commandLine "cmake", ".."
    if (OperatingSystem.current().isWindows()) {
        commandLine "cmake", "-G", "MinGW Makefiles", ".."
    }
    workingDir buildDir
    dependsOn generateJniHeaders
}

task makeWrapCpp(type:Exec) {
    commandLine "make", "-j", availableProcessors
    if (OperatingSystem.current().isWindows()) {
        commandLine "mingw32-make", "-j", availableProcessors
    }
    workingDir buildDir
    dependsOn runCMake
}

task cleanWarpCpp(type:Exec) {
    commandLine "make", "clean"
    if (OperatingSystem.current().isWindows()) {
        commandLine "mingw32-make", "clean"
    }
    workingDir buildDir
    dependsOn runCMake
}

def libFile() {
    if (OperatingSystem.current().isMacOsX()) {
        return "libwarp_lib.dylib"
    } else if (OperatingSystem.current().isLinux()) {
        return "libwarp_lib.so"
    } else if (OperatingSystem.current().isWindows()) {
        return "libwarp_lib.dll"
    } else {
        throw new GradleException("unsupported operating system")
    }
}


task buildJni(type:Copy) {
    doFirst {
        mkdir(getJniPath())
    }
    from buildDir
    include libFile()
    rename libFile(), (OperatingSystem.current().isLinux() ? "libwarp_lib.so" : "libwarp_jni.jnilib")
    into getJniPath()
    dependsOn makeWrapCpp
}

tasks.withType(Test) {
    systemProperty "java.library.path", getJniPath()
}

clean.dependsOn cleanWarpCpp
test.dependsOn buildJni

